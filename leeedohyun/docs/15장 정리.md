디자인 패턴은 소프트웨어 설계에서 반복적으로 발생하는 문제에 대해 반복적으로 적용할 수 있는 해결 방법이다.
디자인 패턴의 목적은 설계를 재사용하는 것이고, 다양한 변경을 다루기 위해 반복적으로 재사용할 수 있는 설계의 묶음이다.

프레임워크는 설계와 코드를 함께 재사용하기 위한 것이다.
디자인 패턴과 프레임워크 모두 협력을 일관성 있게 만들기 위한 방법이다.

# 디자인 패턴과 설계 재사용
## 소프트웨어 패턴
패턴은 특정한 컨텍스트에서 유용할 뿐 아니라, 다른 컨텍스트에서도 적용할 수 있는 아이디어다.
가장 큰 가치는 경험을 통해 축적된 실무 지식을 효과적으로 요약하고 전달할 수 있다는 점에 있다.
패턴은 지식 전달과 커뮤니케이션의 수단으로 활용되므로, 가장 중요한 요소는 패턴의 이름이다.
또한, 패턴은 결코 고립된 채로 존재하지 않는다.

## 패턴 분류
### 아키텍처 패턴
- 디자인 패턴의 상위
- 소프트웨어의 전체적인 구조를 결정하기 위해 사용 
- 미리 정의된 서브시스템들을 제공하고, 각 서브시스템들의 책임을 정의하며 서브시스템들 사이의 관계를 조직화하는 규칙과 가이드라인 포함
- 구체적인 소프트웨어 아키텍처를 위한 템플릿을 제공

### 분석 패턴
- 도메인 내의 개념적인 문제를 해결하는 데 초점을 맞춘다.
- 업무 모델링 시에 발견되는 공통적인 구조를 표현하는 개념들의 집합

### 디자인 패턴
- 특정 정황 내에서 일반적인 설계 문제를 해결하며, 협력하는 컴포넌트들 사이에서 반복적으로 발생하는 구조를 서술

### 이디엄
- 디자인 패턴의 하위
- 특정 프로그래밍 언어에만 국한된 하위 레벨 패턴

## 패턴과 책임-주도 설계
객체지향 설계에서 가장 중요한 일은 올바른 책임을 올바른 객체에 할당하고, 객체 간에 유연한 협력 관계를 구축하는 일이다.
이때 책임과 협력의 윤곽은 캡슐화, 크기, 의존성, 유연성, 성능, 확장 가능성, 재사용성 등 다양한 요소 간의 트레이드오프를 통해 결정된다.

패턴은 공통적으로 활용할 수 있는 역할·책임·협력의 템플릿이다.
이를 따르면 특정 상황에서 적용할 수 있는 설계를 더 쉽고, 더 빠르게 떠올릴 수 있다.
또한 패턴의 구성 요소는 클래스가 아니라 역할이다. 즉, 디자인 패턴의 핵심은 클래스와 메서드가 아니라 역할과 책임이라는 점을 이해하는 것이 중요하다.

## 캡슐화와 디자인 패턴
디자인 패턴의 목적은 특정한 변경을 캡슐화함으로써 유연하고 일관성 있는 협력을 설계할 수 있는 경험을 공유하는 것이다. 
디자인 패턴에서 중요한 것은 구현 방법이나 구조가 아니라 어떤 변경을 캡슐화하는지를 이해하는 것이 중요하다.
그리고 각 디자인 패턴이 변경을 캡슐화하기 위해 어떤 방법을 사용하는지를 이해하는 것이 더 중요하다.

## 패턴은 출발점이다
패턴은 설계의 목표가 돼서는 안 된다. 패턴은 단지 목표로 하는 설계에 이를 수 있는 방향을 제시하는 나침반에 불과하다.
패턴을 사용하면서 부딪히게 되는 대부분의 문제는 패턴을 맹목적으로 사용할 때 발생한다. 대부분의 패턴 입문자가 빠지기 쉬운 함정은 패턴을 적용하는 컨텍스트의 적절성은 무시한 채 패턴의 구조에만 초점을 맞추는 것이다.
해결하려는 문제가 아니라 패턴이 제시하는 구조를 맹목적으로 따르는 것은 불필요하게 복잡하고, 난해하며, 유지보수하기 어려운 시스템을 낳는다.
타당한 이유 없이 패턴을 적용하면 패턴에 익숙한 사람들의 경우에는 설계의 의도를 이해하지 못하게 되고, 패턴을 알지 못하는 사람들은 불필요하게 복잡한 설계를 따라가느라 시간을 낭비하게 된다.
정단한 이유 없이 사용된 모든 패턴은 설계를 복잡하게 만드는 장애물이다.
패턴은 우리가 직면한 문제에 적합하지 않을 수도 있으니, 문제를 분석하고 창의력을 발휘함으로써 패턴을 현재의 문제에 적합하도록 적절하게 수정하라.

결국 디자인 패턴을 사용하는 것도 트레이드 오프의 산물이다.

# 프레임워크와 코드 재사용
## 코드 재사용 대 설계 재사용
재사용 관점에서 보면, 설계 재사용보다 더 나은 방법은 코드 재사용이다. 다양한 도메인에서 그대로 활용 가능한 범용 컴포넌트라는 개념은 현실적으로 실현하기 어렵다.

가장 이상적인 재사용 방식은 설계 재사용과 코드 재사용을 적절히 조합하는 것이다. 
이 두 가지를 결합한 형태가 바로 프레임워크이며, 프레임워크는 코드를 재사용함으로써 설계 아이디어까지 함께 재사용하게 해준다.

## 상위 정책과 하위 정책으로 패키지 분리하기
프레임워크의 핵심은 추상 클래스나 인터페이스와 같은 추상화다.
이러한 추상화는 일관성 있는 협력을 구성하는 핵심 재료이며, 협력을 유연하고 안정적으로 유지하려면 변경을 캡슐화해야 한다.

협력 코드를 작성할 때, 의존성은 가능하면 추상 클래스나 인터페이스와 같은 추상화를 향하도록 설계해야 한다.
만약 변하지 않는 상위 정책이 자주 변하는 세부 사항에 의존한다면, 변경의 파급 효과로 인해 상위 정책이 불안정해진다.
또한 상위 정책은 세부 사항보다 더 다양한 상황에서 재사용될 수 있어야 하지만, 세부 사항에 의존하면 상위 정책이 필요한 모든 경우에 세부 사항까지 함께 가져와야 하므로 재사용성이 크게 떨어진다.

이를 해결하기 위해 의존성 역전 원칙을 적용해, 상위 정책과 세부 사항 모두 추상화에 의존하도록 만든다.
의존성 역전 원칙 관점에서 세부 사항은 곧 변경이므로, 변하는 것과 변하지 않는 것을 물리적으로 분리해야 한다(예: 별도의 패키지로 분리).

하지만 단순히 패키지를 분리하는 것만으로는 충분하지 않다. 핵심은 패키지 간의 의존성 방향이다.
의존성 역전 원칙 따라 분리했다면, 세부 사항을 구현한 패키지는 반드시 상위 정책을 구현한 패키지에 의존해야 하고, 반대로 상위 정책 패키지는 세부 사항 패키지로부터 완전히 독립적이어야 한다.

## 제어 역전 원리
객체지향 설계의 재사용성은 개별 클래스가 아니라, 객체들 사이의 공통적인 협력 흐름에서 나온다.
의존성 역전 원칙은 전통적인 설계 방식과 객체지향 설계를 구분하는 가장 핵심적인 원리다.
시스템이 진화하는 과정에서는 항상 DIP를 따르는 설계가 뒷받침되어야 한다.

프레임워크를 사용하면 제어 흐름의 주체가 개별 애플리케이션에서 프레임워크로 이동한다.
즉, 의존성을 역전시키면 제어 흐름의 주체 또한 역전되며, 이를 제어 역전이라고 한다.
결국 협력을 제어하는 주체는 프레임워크다.

> ### 라이브러리 vs 프레임워크
> - 라이브러리: 개발자가 필요할 때 호출해 사용하는 도구 모음으로 제어 흐름의 주체는 개발자다. 
> - 프레임워크: 프레임워크가 전체 흐름을 제어하며, 개발자는 필요한 부분만 구현해 프레임워크에 제공한다.
