# 프로시저 추상화와 데이터 추상화
## 추상화 매커니즘
| 구분 | 설명                                  
| --- |-------------------------------------
| 프로시저 추상화 | "무엇을 해야 하는가?"를 증심으로 한 추상화 (기능 중심)   |
| 데이터 추상화 | "무엇을 알아야 하는가?"를 중심으로 한 추상화 (데이터 중심) |

## 분해 방식
| 중심 추상화      | 방식             | 설명                  |
|-------------|----------------|---------------------|
| 프로시저 추상화 중심 | 기능 분해          | 기능(절차)을 기준으로 분해     |
| 데이터 추상화 중심  | ADT(추상 데이터 타입) | 데이터 타입을 추상화         |
| 데이터 추상화 중심  | 객체 지향          | 데이터를 중심으로 프로시저를 추상화 |

# 프로시저 추상화와 기능 분해
## 메인 함수로서의 시스템
- 기능은 오랜 기간 동안 시스템 분해의 기준이었다.
- 이 관점에서 추상화의 단위는 프로시저이며, 시스템은 프로시저 단위로 분해된다.
- 프로시저는 반복적/유사한 작업을 모아 중복을 방지하고 로직을 재사용할 수 있게 해준다.
- 인터페이스만 알면 내부 구현을 몰라도 사용할 수 있다는 점에서 프로시저는 추상화이다. 
- 정보 은닉도 가능하지만, 프로시저만으로는 완전한 정보 은닉 체계를 만들기는 어렵다.

## 하향식 접근법
- 최상위 기능 → 더 작은 하위 기능으로 점점 분해
- 마지막 하위 기능이 프로그래밍 언어로 구현 가능한 수준이 될 때까지 분해

## 급여 관리 시스템
- 급여 = 기본급 - (기본급 × 소득세율)

### 기능 분해 구조
```text
직원의 급여를 계산한다
	사용자로부터 소득세율을 입력받는다
		"세율을 입력하세요" 출력한다
		키보드를 통해 세율을 입력받는다
	직원의 급여를 계산한다
		전역 변수에 저장된 직원의 기본급 정보를 얻는다
		급여를 계산한다
	양식에 맞게 결과 출력
		"이름: {직원명}, 급여: {계산된 금액}" 형식에 따라 출력 문자열을 생성한다
```

## 기능 분해에 따른 코드 구현
### 메인 함수
```ruby
def main(name)
  taxRate = getTaxRate()
  pay = calculatePayFor(name, taxRate)
  puts(describeResult(name, pay))
end
```

### 세율 입력
```ruby
def getTaxRate()
  print("세율을 입력하세요: ")
  return gets().chomp().to_f()
end
```

### 직원 정보 및 급여 계산
```ruby
$employees = ["직원A", "직원B", "직원C"]
$basePays = [400, 300, 250]

def calculatePayFor(name, taxRate)
  index = $employees.index(name)
  basePay = $basePays[index]
  return basePay - (basePay * taxRate)
end
```

### 결과 출력
```ruby
def describeResult(name, pay)
  return "이름: #{name}, 급여: #{pay}"
end
```

### 호출 예
```ruby
main("직원C")
```

### 기능 분해 구조
- 기능 분해의 결과는 절차들의 실행 순서를 시간 순서로 나열한 것이다. 
- 책의 목차를 정리하고 내용을 채워나가는 것과 유사하다.
- 기능을 기준으로 필요한 데이터를 결정한다.

## 하향식 기능 분해의 문제점
### 하나의 메인 함수라는 비현실적인 아이디어
- 시스템은 하나의 메인 함수만으로 구성되지 않는다. 
- 시간이 지나면서 요구사항이 변경되고 기능이 추가된다. 
- 결국 시스템은 여러 개의 동등한 수준의 함수 집합으로 확장된다. 
- 실질적으로 대부분의 기능은 독립적이며 완결된 단위다.

### 메인 함수의 빈번한 재설계
- 하나의 메인 함수를 유일한 정상으로 가정한 분해 방식은 확장 시 매번 메인 함수 수정이 필요 
- 시스템 안에는 사실상 여러 개의 ‘정상’이 존재

### 비즈니스 로직과 사용자 인터페이스의 결합
- 하향식 분해는 설계 초기부터 UI와 로직을 함께 고민하도록 유도한다. 
- 결과적으로 두 관심사(UI와 도메인 로직)는 서로 다른 변경 주기를 가짐에도 불구하고 강하게 얽힌다. 
- 이는 변경이 UI에만 국한되지 않고 로직까지 전이되는 구조적 문제로 발전한다.

### 성급하게 결정된 실행 순서
- 설계를 시작하는 시점부터 시스템이 무엇(what)을 해야 하는지가 아니라 어떻게(how) 동작해야 하는지에 집중하도록 만든다. 
- 처음부터 구현을 염두에 두기 때문에 자연스럽게 함수들의 실행 순서를 정의하는 시간 제약을 강조한다.
- 이는 변경에 취약하고, 재사용성과 유연성을 저해한다.

### 데이터 변경으로 인한 파급효과 
- 하향식 기능 분해의 가장 큰 문제점은 어떤 데이터를 어떤 함수가 사용하고 있는지를 추적하기 어렵다는 것이다. 
- 해결책: 데이터를 캡슐화하고, 공개된 퍼블릭 인터페이스를 통해서만 접근하도록 설계해야 한다. → 모듈화, 정보 은닉, 인터페이스 기반 설계

## 언제 하향식 분해가 유용한가?
- 설계가 어느 정도 안정화된 후에는 설계의 다양한 측면을 논리적으로 설명하고 문서화하기에 용이하다.
- 그러나 설계를 문서화하는 데 적절한 방법이 좋은 구조를 설계할 수 있는 방법과 동일한 것은 아니다.

# 모듈
## 정보 은닉과 모듈
- 정보 은닉은 시스템을 모듈 단위로 분해하는 기본 원리다. 핵심은 자주 변경되는 부분을 덜 변경되는 인터페이스 뒤로 감추는 것이다. 
- 정보 은닉은 감춰야 할 비밀을 중심으로 시스템을 분할한다.
- 모듈은 다음과 같은 역할을 수행한다.
  - 변경 가능한 비밀을 내부에 감춘다. 
  - 잘 정의된, 안정적인 퍼블릭 인터페이스를 외부에 제공한다.
- 모듈 분해는 “보존의 과정”이다. 감춰야 할 비밀을 중심으로 보호막을 설치한다. 
- 반면, 기능 분해는 “탐색의 과정”이다. 하나의 기능을 구현하기 위해 필요한 기능들을 순차적으로 찾아간다. 
- 모듈이 감춰야 할 비밀의 유형 
  - 복잡성: 복잡한 내부 구현은 간단한 인터페이스 뒤로 감춰야 한다. 
  - 변경 가능성: 변경 가능한 설계 결정은 외부에 노출하지 않아야 한다. 
- 가장 흔한 비밀은 데이터다.

## 모듈의 장점과 한계
### 장점
- 모듈 내부 변경이 전체 시스템에 미치는 영향을 최소화한다. 
- 관심사의 분리를 통해 로직과 UI를 분리할 수 있다. 
- 전역 변수/함수 사용을 줄여 네임스페이스 오염을 방지한다.

### 한계
- 인스턴스 개념을 제공하지 않는다.

# 데이터 추상화와 추상 데이터 타입
## 추상 데이터 타입
- 타입: 변수에 저장할 수 있는 내용물의 종류와 변수에 적용될 수 있는 연산의 가짓수 
- 기존 절차형 언어는 프로시저 추상화를 주로 사용했다. 
- 그러나 프로시저 추상화만으로는 표현력에 한계가 있었다. 
- 추상 데이터 타입은 사람들이 세상을 바라보는 방식에 더 근접하며 추상화 수준을 높인다.

## 추상 데이터 타입을 구현하기 특성
- 타입 정의를 선언할 수 있어야 한다. 
- 해당 타입의 오퍼레이션 집합을 정의할 수 있어야 한다. 
- 제공된 오퍼레이션을 통해서만 내부 데이터에 접근할 수 있어야 한다. 
- 해당 타입의 여러 인스턴스를 생성할 수 있어야 한다.

# 클래스
## 클래스는 추상 타입인가?
- 동일하지 않다. 핵심 차이점은 클래스는 상속과 다형성을 지원하지만 추상 데이터 타입은 그렇지 않다는 점이다. 
- 추상 데이터 타입: 타입을 추상화함. 
- 클래스: 절차를 추상화함. 
- 예: Employee는 개념적으로 정규직과 아르바이트 직원을 포괄하는 복합 개념이다. 
- 타입 추상화는 하나의 물리적 타입 안에 모든 개념적 타입을 감춘다.

## 추상 데이터 타입에서 클래스로 변경하기
```ruby
class Employee
	attr_reader :name, :basePay
	
	def initialize(name, basePay)
		@name = name
		@basePay = basePay
	end
	
	def calculatePay(taxRate)
		raise NotImplementedError
	end
	
	def monthlyBasePay()
		raise NotImplementedError
	end
end
```

```ruby
class SalariedEmployee < Employee
	def initialize(name, basePay)
		super(name, basePay)
	end
	
	def calculatePay(taxRate)
		return basePay - (basePay * taxRate)
	end
	
	def monthlyBasePay()
		return basePay
	end
end
```

```ruby
class HourlyEmployee < Employee
	attr_reader :timeCard
	def initialize(name, basePay, timeCard)
		super(name, basePay)
		@timeCard = timeCard
	end
	
	def calculatePay(taxRate)
		return (basePay * timeCard) - (basePay * timeCard) * taxRate
	end
	
	def calculatePay(taxRate)
		return 0
	end
end
```

- 추상 데이터 타입에서는 하나의 타입(Employee)만 존재한다. 
- 클래스 구조에서는 구체적인 직원 타입을 명시적으로 다룰 수 있다. 
- 클라이언트는 모든 타입을 Employee의 인스턴스로 다룰 수 있다.

```ruby
def sumOfBasePays()
	result = 0
	for each in $employees
		result += each.monthlyBasePay()
	end
	put(result)
end
```

## 변경을 기준으로 선택하라
- 조건문 기반 구조는 변경에 취약하다. 
- 객체지향은 다형성을 이용해 조건문을 대체한다. 
- 새로운 직원 유형이 생기면, Employee 계층에 서브클래스를 추가하고 메서드를 오버라이드하면 된다. 
- 기존 코드를 수정하지 않고도 확장이 가능하다 → 개방-폐쇄 원칙(OCP)

| 변경 유형    | 적합한 추상화
|----------| ----------------
| 타입 추가    | 객체지향 구조
| 오퍼레이션 추가 | 추상 데이터 타입

- 설계의 유용성은 변경 방향과 빈도에 따라 달라진다.

## 협력이 중요하다
- 단순히 타입/오퍼레이션을 분류해 클래스 구조를 만드는 것이 객체지향 설계는 아니다. 
- 객체지향의 핵심은 역할, 책임, 협력이다. 
- 협력을 중심으로 필요한 책임을 분배한 뒤, 그 책임 수행 방식에 따라 추상화를 도입해야 한다. 
- 클래스 계층과 다형성은 협력이라는 문맥에서 책임을 수행하는 방식으로 도출되어야 하며, 그 자체가 목적이 되어서는 안 된다.
